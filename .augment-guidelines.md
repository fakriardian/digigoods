# Augment Guidelines for Digigoods API

## Code Styles and Conventions

### General Java Conventions

- Use Lombok to reduce boilerplate code, especially when defining DTO classes and entity classes
- Refer to [`.editorconfig`](./.editorconfig) for general code styles such as indentation, line length, end-of-line symbols
- Run `mvn checkstyle:check` to check for violations of Java code style. If violations found, read the report and try to fix them
- Use meaningful variable names and follow camelCase convention
- Add comprehensive Javadoc comments for all public methods and classes
- Use `@Service`, `@Repository`, `@Controller` annotations appropriately for Spring components

### Entity and Model Classes

- All JPA entities must use Lombok annotations: `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`
- Use `@Entity` and `@Table(name = "table_name")` annotations for all entities
- Use `@Id` and `@GeneratedValue(strategy = GenerationType.IDENTITY)` for primary keys
- Use `@Column` annotations with appropriate constraints (nullable, unique, precision, scale)
- For BigDecimal fields representing money, always use `precision = 10, scale = 2`
- Use `@ManyToOne`, `@OneToMany`, `@ManyToMany` with proper `@JoinColumn` and `@JoinTable` configurations
- Initialize collections with `new HashSet<>()` for Set fields
- Use `@PrePersist` for automatic timestamp fields like `orderDate`

### DTO Classes

- All DTO classes must use Lombok annotations: `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`
- Use Jakarta validation annotations: `@NotNull`, `@NotBlank`, `@NotEmpty` with descriptive error messages
- Include comprehensive Javadoc comments describing the DTO's purpose
- Use meaningful field names that clearly indicate their purpose
- For response DTOs, provide multiple constructors when needed for flexibility

### Service Classes

- All service classes must be annotated with `@Service`
- Use constructor injection for dependencies (no `@Autowired` on fields)
- Include comprehensive Javadoc comments for all public methods with `@param` and `@return` tags
- Use meaningful method names that clearly describe the operation
- Throw specific custom exceptions rather than generic RuntimeException
- Follow the pattern: validate input → perform business logic → return result
- Use private helper methods to break down complex operations into smaller, testable units

### Exception Handling

- Create custom exceptions that extend RuntimeException for business logic errors
- All custom exceptions should have meaningful default messages
- Use specific exception types: `ProductNotFoundException`, `InvalidDiscountException`, etc.
- Include descriptive error messages that help with debugging
- Use `@ControllerAdvice` and `@ExceptionHandler` for global exception handling

### Repository Layer

- Extend `JpaRepository<Entity, ID>` for all repository interfaces
- Use meaningful method names following Spring Data JPA conventions
- Use `@Query` annotations for complex queries when method names become too long

## Testing Guidelines

### Test Structure and Naming

- Use JUnit 5 test framework. To run the unit test suite, run `mvn test`
- Name test classes with the suffix `Test` (e.g., `ProductServiceTest`)
- Name test methods using Given-When-Then format: `givenCondition_whenAction_thenExpectedResult`
- Add `@DisplayName` annotation to all test methods with descriptive names
- Follow the Arrange-Act-Assert (AAA) pattern with clear one-liner comments denoting each section

### Test Annotations and Setup

- Use `@ExtendWith(MockitoExtension.class)` for unit tests with mocks
- Use `@Mock` for mocking dependencies and `@InjectMocks` for the class under test
- Use `@BeforeEach` for test setup and initialization
- Use `@Nested` classes with `@DisplayName` for grouping related tests

### Test Coverage and Quality

- New code should have corresponding unit tests with comprehensive coverage
- Integration tests of the API should be implemented using Spring's `MockMvc` that can run locally
- Functional tests of the API should be implemented using Postman collections executed with `newman`
- Make sure tests pass before and after making modifications to the codebase
- Test both success scenarios and failure/edge cases
- Use meaningful assertions with descriptive failure messages
- Mock external dependencies and focus on testing the unit in isolation

### Test Data and Mocking

- Create test data objects in `@BeforeEach` methods for reusability
- Use `when().thenReturn()` for stubbing mock behavior
- Use `verify()` to ensure mock interactions occurred as expected
- Use `assertThrows()` for testing exception scenarios
- Use static imports for assertion methods to improve readability

## Code Coverage Requirements

### Coverage Analysis

- When asked to increase coverage for a specific source code file, check the coverage report first
- The coverage report of a source code file can be found in `target/site/jacoco/[package name]/[class name].html`
- When reading the coverage report, identify which lines and branches are not yet covered
- Make sure to run `mvn test` before and after adding tests to verify coverage improvement

### Coverage Standards

- Aim for high line coverage (>90%) for service classes
- Ensure branch coverage for all conditional logic
- Test all public methods and their edge cases
- Include tests for exception handling scenarios
- Focus on complex business logic branches and integration points with dependencies

## Database and Configuration

### Database Conventions

- Use Liquibase for database migrations with YAML format
- Follow snake_case naming convention for database table and column names
- Use meaningful table names that reflect the entity purpose
- Use appropriate data types: BIGINT for IDs, DECIMAL(10,2) for money, VARCHAR for strings
- Always include proper foreign key constraints

### Configuration Management

- Use `application.properties` for configuration values
- Use `@Value` annotation to inject configuration properties
- Provide sensible defaults for configuration values
- Use environment-specific profiles when needed

## Security and Best Practices

### JWT and Authentication

- Use strong secret keys for JWT signing (minimum 256 bits)
- Set appropriate expiration times for JWT tokens
- Validate JWT tokens properly in security filters
- Use BCrypt for password hashing

### Input Validation

- Always validate input parameters using Jakarta validation annotations
- Throw specific exceptions for validation failures
- Sanitize user inputs to prevent injection attacks
- Use proper HTTP status codes for different error scenarios

### Security Component Unit Testing Standards

#### Objective and Scope

The Digigoods API implements comprehensive unit testing for all security components to ensure robust authentication and authorization mechanisms. This section documents the enterprise-grade testing standards achieved for security-critical components.

#### Components Tested and Coverage Results

**1. JwtAuthenticationEntryPoint**

- **Coverage Improvement**: 24.2% → 100% instruction coverage
- **Test File**: `JwtAuthenticationEntryPointTest.java`
- **Test Cases**: 11 comprehensive tests
- **Focus Areas**: Authentication exception handling, HTTP response configuration, error response validation

**2. JwtAuthenticationFilter**

- **Coverage Improvement**: 9.4% → 100% instruction coverage
- **Test File**: `JwtAuthenticationFilterTest.java`
- **Test Cases**: 13 comprehensive tests
- **Focus Areas**: JWT token processing, authorization header validation, exception handling, SecurityContext management

**3. UserDetailsServiceImpl**

- **Coverage Improvement**: 81.3% → 100% instruction coverage
- **Test File**: `UserDetailsServiceImplTest.java`
- **Test Cases**: 17 comprehensive tests
- **Focus Areas**: User loading, UserDetails object creation, repository integration, edge case handling

#### Security Testing Quality Standards

**Test Architecture Requirements:**

- Use `@ExtendWith(MockitoExtension.class)` for all security component tests
- Mock all external dependencies (HttpServletRequest, HttpServletResponse, FilterChain, UserRepository)
- Use `@Nested` classes with descriptive `@DisplayName` annotations for logical test grouping
- Follow Given-When-Then naming convention for all test methods

**Coverage Requirements:**

- **100% instruction coverage** mandatory for all security components
- **100% branch coverage** for all conditional logic in security flows
- **Exception scenario testing** for all authentication and authorization failure paths
- **Edge case validation** including null values, empty strings, malformed tokens

**Security-Specific Test Scenarios:**

- **Authentication Flow Testing**: JWT token extraction, validation, expiration, malformation
- **Authorization Testing**: Unauthorized access, missing tokens, invalid credentials
- **HTTP Response Validation**: Status codes (401), content-type headers, JSON response structure
- **SecurityContext Testing**: Authentication object population, filter chain continuation
- **User Management Testing**: User loading, username validation, authority assignment

#### Test Quality Assurance Metrics

**Final Achievement Status:**

- **Total Security Tests**: 41 comprehensive test cases
- **Overall Test Suite**: 157 tests (100% passing)
- **Project Coverage**: 98% instruction coverage, 98% branch coverage
- **Code Quality**: 0 checkstyle violations
- **Build Status**: All tests passing with enterprise-grade reliability

**Mock Verification Standards:**

- Verify all method calls on mocked dependencies
- Validate parameter values passed to mocked methods
- Ensure proper interaction sequences in authentication flows
- Test both positive and negative interaction scenarios

#### Security Testing Best Practices

**JSON Response Testing:**

- Parse JSON responses using ObjectMapper for field validation
- Verify all required fields (status, error, message, path, timestamp)
- Handle dynamic fields (timestamps) appropriately in assertions
- Test different request URI scenarios and error message variations

**Exception Testing Patterns:**

- Test all JWT-related exceptions (ExpiredJwtException, MalformedJwtException, SignatureException)
- Verify proper exception handling without exposing sensitive information
- Test authentication exceptions (BadCredentialsException, InsufficientAuthenticationException)
- Validate UsernameNotFoundException scenarios with appropriate error messages

**Integration Points:**

- Test filter chain continuation in all scenarios
- Verify SecurityContext population and cleanup
- Test UserDetailsService integration with repository layer
- Validate authentication entry point integration with Spring Security

#### Maintenance and Future Standards

**Regression Prevention:**

- All security component changes must maintain 100% test coverage
- New security features require comprehensive test coverage before implementation
- Security tests must be included in CI/CD pipeline quality gates
- Regular security test review and updates with framework upgrades

**Documentation Requirements:**

- All security tests must include comprehensive `@DisplayName` annotations
- Test methods should clearly document the security scenario being validated
- Complex security flows should include inline comments explaining the test logic
- Security test failures must provide clear diagnostic information for debugging

## Documentation and Comments

### Code Documentation

- Include comprehensive Javadoc for all public classes and methods
- Use `@param`, `@return`, `@throws` tags in Javadoc
- Write clear, concise comments that explain the "why" not just the "what"
- Keep comments up-to-date with code changes

### API Documentation

- Document all REST endpoints with proper HTTP methods and status codes
- Include example request/response payloads
- Document authentication requirements
- Provide clear error response formats
