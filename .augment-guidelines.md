# Augment Guidelines for Digigoods API

## Code Styles and Conventions

### General Java Conventions
- Use Lombok to reduce boilerplate code, especially when defining DTO classes and entity classes
- Refer to [`.editorconfig`](./.editorconfig) for general code styles such as indentation, line length, end-of-line symbols
- Run `mvn checkstyle:check` to check for violations of Java code style. If violations found, read the report and try to fix them
- Use meaningful variable names and follow camelCase convention
- Add comprehensive Javadoc comments for all public methods and classes
- Use `@Service`, `@Repository`, `@Controller` annotations appropriately for Spring components

### Entity and Model Classes
- All JPA entities must use Lombok annotations: `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`
- Use `@Entity` and `@Table(name = "table_name")` annotations for all entities
- Use `@Id` and `@GeneratedValue(strategy = GenerationType.IDENTITY)` for primary keys
- Use `@Column` annotations with appropriate constraints (nullable, unique, precision, scale)
- For BigDecimal fields representing money, always use `precision = 10, scale = 2`
- Use `@ManyToOne`, `@OneToMany`, `@ManyToMany` with proper `@JoinColumn` and `@JoinTable` configurations
- Initialize collections with `new HashSet<>()` for Set fields
- Use `@PrePersist` for automatic timestamp fields like `orderDate`

### DTO Classes
- All DTO classes must use Lombok annotations: `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`
- Use Jakarta validation annotations: `@NotNull`, `@NotBlank`, `@NotEmpty` with descriptive error messages
- Include comprehensive Javadoc comments describing the DTO's purpose
- Use meaningful field names that clearly indicate their purpose
- For response DTOs, provide multiple constructors when needed for flexibility

### Service Classes
- All service classes must be annotated with `@Service`
- Use constructor injection for dependencies (no `@Autowired` on fields)
- Include comprehensive Javadoc comments for all public methods with `@param` and `@return` tags
- Use meaningful method names that clearly describe the operation
- Throw specific custom exceptions rather than generic RuntimeException
- Follow the pattern: validate input → perform business logic → return result
- Use private helper methods to break down complex operations into smaller, testable units

### Exception Handling
- Create custom exceptions that extend RuntimeException for business logic errors
- All custom exceptions should have meaningful default messages
- Use specific exception types: `ProductNotFoundException`, `InvalidDiscountException`, etc.
- Include descriptive error messages that help with debugging
- Use `@ControllerAdvice` and `@ExceptionHandler` for global exception handling

### Repository Layer
- Extend `JpaRepository<Entity, ID>` for all repository interfaces
- Use meaningful method names following Spring Data JPA conventions
- Use `@Query` annotations for complex queries when method names become too long

## Testing Guidelines

### Test Structure and Naming
- Use JUnit 5 test framework. To run the unit test suite, run `mvn test`
- Name test classes with the suffix `Test` (e.g., `ProductServiceTest`)
- Name test methods using Given-When-Then format: `givenCondition_whenAction_thenExpectedResult`
- Add `@DisplayName` annotation to all test methods with descriptive names
- Follow the Arrange-Act-Assert (AAA) pattern with clear one-liner comments denoting each section

### Test Annotations and Setup
- Use `@ExtendWith(MockitoExtension.class)` for unit tests with mocks
- Use `@Mock` for mocking dependencies and `@InjectMocks` for the class under test
- Use `@BeforeEach` for test setup and initialization
- Use `@Nested` classes with `@DisplayName` for grouping related tests

### Test Coverage and Quality
- New code should have corresponding unit tests with comprehensive coverage
- Integration tests of the API should be implemented using Spring's `MockMvc` that can run locally
- Functional tests of the API should be implemented using Postman collections executed with `newman`
- Make sure tests pass before and after making modifications to the codebase
- Test both success scenarios and failure/edge cases
- Use meaningful assertions with descriptive failure messages
- Mock external dependencies and focus on testing the unit in isolation

### Test Data and Mocking
- Create test data objects in `@BeforeEach` methods for reusability
- Use `when().thenReturn()` for stubbing mock behavior
- Use `verify()` to ensure mock interactions occurred as expected
- Use `assertThrows()` for testing exception scenarios
- Use static imports for assertion methods to improve readability

## Code Coverage Requirements

### Coverage Analysis
- When asked to increase coverage for a specific source code file, check the coverage report first
- The coverage report of a source code file can be found in `target/site/jacoco/[package name]/[class name].html`
- When reading the coverage report, identify which lines and branches are not yet covered
- Make sure to run `mvn test` before and after adding tests to verify coverage improvement

### Coverage Standards
- Aim for high line coverage (>90%) for service classes
- Ensure branch coverage for all conditional logic
- Test all public methods and their edge cases
- Include tests for exception handling scenarios
- Focus on complex business logic branches and integration points with dependencies

## Database and Configuration

### Database Conventions
- Use Liquibase for database migrations with YAML format
- Follow snake_case naming convention for database table and column names
- Use meaningful table names that reflect the entity purpose
- Use appropriate data types: BIGINT for IDs, DECIMAL(10,2) for money, VARCHAR for strings
- Always include proper foreign key constraints

### Configuration Management
- Use `application.properties` for configuration values
- Use `@Value` annotation to inject configuration properties
- Provide sensible defaults for configuration values
- Use environment-specific profiles when needed

## Security and Best Practices

### JWT and Authentication
- Use strong secret keys for JWT signing (minimum 256 bits)
- Set appropriate expiration times for JWT tokens
- Validate JWT tokens properly in security filters
- Use BCrypt for password hashing

### Input Validation
- Always validate input parameters using Jakarta validation annotations
- Throw specific exceptions for validation failures
- Sanitize user inputs to prevent injection attacks
- Use proper HTTP status codes for different error scenarios

## Documentation and Comments

### Code Documentation
- Include comprehensive Javadoc for all public classes and methods
- Use `@param`, `@return`, `@throws` tags in Javadoc
- Write clear, concise comments that explain the "why" not just the "what"
- Keep comments up-to-date with code changes

### API Documentation
- Document all REST endpoints with proper HTTP methods and status codes
- Include example request/response payloads
- Document authentication requirements
- Provide clear error response formats
